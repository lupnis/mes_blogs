# title:高级算法复习

> author:lupnis
> profile:https://github.com/lupnis
> date:2024/12/27

> banner:https://www.qdxq.sdu.edu.cn/__local/0/C6/D8/E0DDE31BD89BA76FFBF6B461200_B4E882C1_647757.jpg

> thumb:https://www.qdxq.sdu.edu.cn/__local/0/C6/D8/E0DDE31BD89BA76FFBF6B461200_B4E882C1_647757.jpg

> tags:算法,高级算法,课程

> abstract:算法复习笔记整理

# 写在最前面

老师说这门课不会给挂，但是不复习心里没底🥺

感谢大佬[Haozhe](https://github.com/sailist)的[复习总结](http://haozhe.lumo-tech.top/AdAlgo/)，和学长学姐的复习资料 ~ 

**<font color=yellow>！！注意！！本复习笔记仅包含基础知识点及SAT，2SAT，3SAT，TSP，背包，划分，独立集，独立任务排工，顶点覆盖，集合覆盖！！</font>**


# 基础概念

## 基础定义

算法+数据结构=程序

算法两个要素：输入、输出，要有严格的描述

实例：描述问题的所有参量。

询问：陈述问题所求的解的格式和解应满足的性质。

> **算法**：
> + “对每个问题实例，计算机都能计算出满足询问条件的正确答案”的计算方法。
> + 是一个过程和语句的集合，其中语句有顺序，算法按照顺序执行语句，处理实例，得到正确答案。
> + 对每个实例都能得到正确答案。

算法可以理解为一种计算方法，但这种方法一定能用计算机来计算，能够使用程序实现。

> **程序**：
> 程序是算法在计算机上的具体实现。算法与程序没有本质区别，算法一般不关心在哪台计算机上运行而程序关心。

## 渐进估计技术和基本规则

考虑算法的总操作次数，这个总操作次数被称为算法的时间复杂度/性。**操作**的概念具体情况具体分析。

一个算法所需要的存储单元数目称为算法的空间复杂度。

<font color=red>时间和空间复杂度，不能也无法太精确</font>

<font color=yellow>当实例规模很小时，说明算法的时间复杂度和空间复杂度意义不大。</font>

一般来说，计算复杂度只考虑算法运行的“界”

默认时间复杂度一定是**实例规模**的**函数**，实例规模逐渐增大，时间复杂度也增大，因此只要描述时间复杂度随着实例规模增大而增大的增长率就可以了。

定义$T(n)$为算法复杂性函数，其渐进估计即讨论随着实例输入长度$n$ 的增长，$T(n)$的增长趋势。在估计时，一般使用$O(\bullet)$表示其上界，用$\Omega(\bullet)$表示其下界。

 1. 如果存在$n_0$和$C$，使得当$n > n_0$时，有$T(n) \leq Cf(n)$，则记为$T(n) = O(f(n))$
 2. 如果存在常数$C$和无穷多个$n$，使得$T(n) \geq Cg(n)$，则记为$T(n) = \Omega(g(n))$ <font color=yellow>
 3. 若存在$n_0$和$C$，使得当$n > n_0$时，$T(n) \geq Cg(n)$，则称$T(n) = \Omega(g(n))$，这个节的定义有时是平凡的 </font>

## 分治

先分开把大问题化成小问题，求解小问题，再把小问题解合并，最终成为大问题的解。e.g. **Merge Sort**

## 贪心

寻求当前最好的结果，最终得到最终目标。贪心技术**能够找到可行解，但是未必能找到最优解**。e.g. **Dijkstra**

## 动态规划

动态规划目的是为了寻求最优解，能寻找到最优解。通过遍历解空间中的所有解，得到所需要的或最优的解。动态规划通过规划方法把所有可能是最优解的解规划出来。**先组装规模小的实例的解，再逐渐增大实例规模，得到最终的解。**Floyd-Warshall**

## 回溯

e.g. **$\alpha$/$\beta$ 剪枝**


## 局部搜索

遗传算法，演化算法，蚁群算法......

## P、NP、NPC、NP-Hard

### 确定图灵机与P类

确定图灵机：DTM

> 我们编的程序就是告诉计算机怎样改变状态。真正实现计算机，还有很多工作，怎样用语言的形式描述状态转换规则。哪些硬件，哪些软件，电子计算机怎样实现。
> 先有模型，后有计算机。

$\Sigma$为符号集合

$\Sigma^*$表示$\Sigma$中符号的所有有限串集合

$L \subseteq \Sigma^*$表示问题的所有实例集合

如果问题的可行解也能用$\Sigma$中的符号串表示，那么问题本身可以看成从$L$到$\phi$的一个映射。

**定义时空复杂性（度）**：问题$\pi=<\Sigma, L, \phi>$是用某个DTM程序可解的，任意实例$I \in L$，只要$I$写在带上，从$q_0$状态开始执行，总可以经过有限步计算**停机**，且在带上保留着该问题的解答$\phi(I) \in \{yes, no\}$。

其中所用的状态数为计算的时间复杂度$T_M(I)$，计算中所占用的带方格数为空间复杂度$S_M(I)$。

**<font color=yellow>定义：多项式时间可解的</font>**：存在一个解答$\pi$的DTM程序$M$，和多项式函数$P(n)$，使$T_M(n) \leq P(n)$，则称$M$是多项式时间程序。

如果问题$\pi$存在多项式时间的程序，则称问题$\pi$是多项式时间可计算的——**P类问题**

<font color=yellow>在计算机上多项式时间算法，等价于DTM多项式时间程序</font>

### 非确定图灵机与NP类

非确定图灵机：NTM

NTM工作分为：
 1. 猜测阶段：猜测部件写在带上的一些符号
 2. 验证阶段：执行

NTM实际上是验证机器，由猜测部件去猜最好的符号串，然后状态控制器根据符号去执行最好的动作，从而求出最优解，根据猜测部件求出的解回答结果。
 + 猜测部件猜测正确，则我们只需要编验证程序就行，如果猜错就无法保证最后回答
 + 猜测部件应能保证能猜出来

**<font color=yellow>定义：非多项式时间可解的</font>**：存在解答$\pi$的一个验证程序$M$，和多项式函数$P(n)$，使$T_{NTM}(n) \leq P(n)$。如果验证时间是多项式的就是NTM多项式时间可解的——NP类问题

**定理**：NP类的问题，均可用DTM在$T(n)=O(2^{P(n)})$时间内求解。

### 多项式变换（归约）与NPC类

**<font color=yellow>多项式变换定义</font>**：希望将$\pi_1$变为$\pi_2$，若$\pi_2$多项式时间可解，则$\pi_1$也多项式时间可解。

$$
\pi_1=<\Sigma_1, L_1, \phi_1>; \pi_2=<\Sigma_2, L_2, \phi_2>,\\

f: \Sigma_1^* \to \Sigma_2^*, I \in L_1, f(I) \in L_2, \phi_1(I)=\phi_2(f(I))
$$
其中，$f$变换能够在$p(|I|=n)$时间内计算完成，**则$f$称为由$\pi_1$到$\pi_2$的多项式归约**

若$\pi_1$可以多项式归约到$\pi_2$，则：若$\pi_2$存在多项式算法，则$\pi_1$也有多项式算法：

$$
\pi_1=<\Sigma_1, L_1, \phi_1>; \pi_2=<\Sigma_2, L_2, \phi_2>,\\

f: \Sigma_1^* \to \Sigma_2^*, I \in L_1, f(I) \in L_2,\\
\phi_1(I)=1\longleftrightarrow\phi_2(f(I))=1
$$

若有一个特殊的NP问题$\pi$，任意一个NP问题均可多项式时间归约到该问题，则该问题是NP-Complete(NPC)的。

若该NPC问题可以多项式时间解决，则其他所有NP问题都可以在多项式时间解决。

$\propto$ 是多项式变换符号，

**定义**：$\pi \in NP, \forall \pi_1 \in NP,\pi_1 \propto \pi$，则称$\pi$是NPC的

**定理**：若有$\pi \in NPC$，则（1）$P \neq NP$，（2）$\pi \notin P$，即$P \neq NP \longleftrightarrow \pi \notin P$

### 图灵归约与NP-Hard

图灵归约用于证明一个问题是 NP-hard，从而说明某些搜索问题的计算复杂性。其定义基于神谕图灵机(Oracle Turing Machine, OTM)。

OTM 和 DTM 很相似，但比 DTM 多了一个神谕状态，和神谕纸带。

这多出来的神谕状态可以被看做是一个黑盒子函数，用于帮助我们求解某些难以求解的问题。

**比如，已知货郎判定问题是 NP-hard，那么货郎优化问题的难度应该如何表示？**

假设存在一个在多项式时间内解货郎优化问题的算法 A，随后用该算法求出最短路径 L，如果 L大于判定问题，就输出 NO，否则输出 YES。通过这种方法，我们用货郎优化问题解决了货郎判定问题

在上面的例子中，算法 A 就是神谕，以假设货郎优化问题的算法为多项时间为基础，设计算法并证明货郎判定问题是多项式时间的过程，被称为图灵归约。上述的过程读作将货郎判定问题图灵归约到货郎优化问题。此时，根据图灵归约的定义，货郎判定问题是 NP-hard，因此货郎优化问题也是NP-hard。

> 可以看出，如果货郎优化问题可以在多项式时间内解答，那么货郎判定问题一定可以在多项式时间内解答；但是如果货郎判定问题可以在多项式时间内解答，根据上述算法，货郎优化问题不一定可以在多项式时间内解答。（可以根据上述图灵归约认定货郎优化问题比货郎判定问题难）
> 不过实际上，也可以将货郎优化问题图灵归约到货郎判定问题。这种情况下就可以认为货郎优化问题是NP等价的。

NPH问题不一定在多项式时间内被验证正确性，NPC为NPH的子集，因此NPC问题也可以看作是NPH

将问题 A 图灵归约到问题 B，分以下几步：

 1. 假设存在一个复杂度为 $O(1)$ 的求解问题 B 的算法 $M$
 2. 利用算法 $M$ 设计一个多项式时间算法解决问题 A。

其中，说明问题 B 是 NP 的步骤可以省略，因为 NP-hard 不要求问题是 NP 的。

NP-hard 问题由图灵归约得到，有三种途径：
 1. 一个问题能由任意一个NP问题图灵归约到该问题，则该问题是NP-Hard。
 2. 一个问题能由某个NPC问题图灵归约到该问题，则该问题为NP-hard。
 3. 若 $\pi_{1}$ 是NP-hard问题， $\pi_{1}$ 可以图灵归约到 $\pi_{2}$（即 $\pi_{1}\propto_t \pi_{2}$）, 则 $\pi_{2}$ 也是NP-hard问题。

### 几个的关系

当$P \neq NP$， NP问题和NPH问题交集为NPC问题；当$P=NP$时，则有$P = NP = NPC$

## 一般的问题

### 判定问题

如划分问题、团问题

### 搜索（优化）问题

如TSP

# 布尔可满足性问题 (boolean SATisfiability problem, SAT)

## SAT 介绍

SAT 问题属于决定性问题，也是第一个被证明属于NPC的问题，1970年 Cook 证明 SAT 问题是NPC问题。即Cook定理。Cook说明若SAT多项式时间可解，则所有NP问题多项式时间可解。

Cook定理证明 SAT 问题属于 NPC 问题的核心步骤：
 1. 证明 SAT 问题属于 NP 问题，这明显成立（给定一个真值指派，按顺序求解即可）
 2. 证明其他所有属于 NP 类的判定问题都可以通过某多项式变换变换为 SAT 问题

## SAT 问题定义

布尔变量集合$U=\left\{u_{1}, u_{2}, \cdots, u_{n}\right\}$，项集合$C=\left\{C_{1}, C_{2}, \cdots, C_{m}\right\}$，其中：
$$
C_{i}=\left\{u[i, 1], \cdots, u\left[i, k_{i}\right]\right\}
\subseteq U \cup \bar{U}, \quad \bar{U}=\left\{\bar{u}_{1}, \cdots, \bar{u}_{n}\right\}
$$

询问 是否存在 $U$ 的真值指派:$U \rightarrow\{\mathrm{F}, \mathrm{T}\}$，满足
$$
\bigwedge_{i=1}^{m}\left(\sum_{j=1}^{k_{i}} u[i, j]\right)=\mathrm{T}
$$

## SAT 问题证明

。。。

# 2SAT

# 3SAT

# TSP

# 背包

# 划分

# 独立集

# 独立任务排工

# 顶点覆盖

# 集合覆盖














