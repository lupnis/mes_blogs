# title:高级算法复习

> author:lupnis
> profile:https://github.com/lupnis
> date:2024/12/27

> banner:https://www.qdxq.sdu.edu.cn/__local/0/C6/D8/E0DDE31BD89BA76FFBF6B461200_B4E882C1_647757.jpg

> thumb:https://www.qdxq.sdu.edu.cn/__local/0/C6/D8/E0DDE31BD89BA76FFBF6B461200_B4E882C1_647757.jpg

> tags:算法,高级算法,课程

> abstract:算法复习笔记整理

# 写在最前面

老师说这门课不会给挂，但是不复习心里没底 🥺

感谢大佬[Haozhe](https://github.com/sailist)的[复习总结](http://haozhe.lumo-tech.top/AdAlgo/)，和学长学姐的复习资料 ~

**<font color=yellow>！！注意！！本复习笔记仅包含基础知识点及 SAT，2SAT，3SAT，TSP，背包，划分，独立集，独立任务排工，顶点覆盖，集合覆盖！！</font>**

# 基础概念

## 基础定义

算法+数据结构=程序

算法两个要素：输入、输出，要有严格的描述

实例：描述问题的所有参量。

询问：陈述问题所求的解的格式和解应满足的性质。

> **算法**：
>
> - “对每个问题实例，计算机都能计算出满足询问条件的正确答案”的计算方法。
> - 是一个过程和语句的集合，其中语句有顺序，算法按照顺序执行语句，处理实例，得到正确答案。
> - 对每个实例都能得到正确答案。

算法可以理解为一种计算方法，但这种方法一定能用计算机来计算，能够使用程序实现。

> **程序**：
> 程序是算法在计算机上的具体实现。算法与程序没有本质区别，算法一般不关心在哪台计算机上运行而程序关心。

## 渐进估计技术和基本规则

考虑算法的总操作次数，这个总操作次数被称为算法的时间复杂度/性。**操作**的概念具体情况具体分析。

一个算法所需要的存储单元数目称为算法的空间复杂度。

<font color=red>时间和空间复杂度，不能也无法太精确</font>

<font color=yellow>当实例规模很小时，说明算法的时间复杂度和空间复杂度意义不大。</font>

一般来说，计算复杂度只考虑算法运行的“界”

默认时间复杂度一定是**实例规模**的**函数**，实例规模逐渐增大，时间复杂度也增大，因此只要描述时间复杂度随着实例规模增大而增大的增长率就可以了。

定义$T(n)$为算法复杂性函数，其渐进估计即讨论随着实例输入长度$n$ 的增长，$T(n)$的增长趋势。在估计时，一般使用$O(\bullet)$表示其上界，用$\Omega(\bullet)$表示其下界。

1.  如果存在$n_0$和$C$，使得当$n > n_0$时，有$T(n) \leq Cf(n)$，则记为$T(n) = O(f(n))$
2.  如果存在常数$C$和无穷多个$n$，使得$T(n) \geq Cg(n)$，则记为$T(n) = \Omega(g(n))$ <font color=yellow>
3.  若存在$n_0$和$C$，使得当$n > n_0$时，$T(n) \geq Cg(n)$，则称$T(n) = \Omega(g(n))$，这个节的定义有时是平凡的 </font>

## 分治

先分开把大问题化成小问题，求解小问题，再把小问题解合并，最终成为大问题的解。e.g. **Merge Sort**

## 贪心

寻求当前最好的结果，最终得到最终目标。贪心技术**能够找到可行解，但是未必能找到最优解**。e.g. **Dijkstra**

## 动态规划

动态规划目的是为了寻求最优解，能寻找到最优解。通过遍历解空间中的所有解，得到所需要的或最优的解。动态规划通过规划方法把所有可能是最优解的解规划出来。**先组装规模小的实例的解，再逐渐增大实例规模，得到最终的解。e.g. **Floyd-Warshall\*\*

## 回溯

e.g. **$\alpha$/$\beta$ 剪枝**

## 局部搜索

遗传算法，演化算法，蚁群算法......

## P、NP、NPC、NP-Hard

### 确定图灵机与 P 类

确定图灵机：DTM

> 我们编的程序就是告诉计算机怎样改变状态。真正实现计算机，还有很多工作，怎样用语言的形式描述状态转换规则。哪些硬件，哪些软件，电子计算机怎样实现。
> 先有模型，后有计算机。

$\Sigma$为符号集合

$\Sigma^*$表示$\Sigma$中符号的所有有限串集合

$L \subseteq \Sigma^*$表示问题的所有实例集合

如果问题的可行解也能用$\Sigma$中的符号串表示，那么问题本身可以看成从$L$到$\phi$的一个映射。

**定义时空复杂性（度）**：问题$\pi=<\Sigma, L, \phi>$是用某个 DTM 程序可解的，任意实例$I \in L$，只要$I$写在带上，从$q_0$状态开始执行，总可以经过有限步计算**停机**，且在带上保留着该问题的解答$\phi(I) \in \{yes, no\}$。

其中所用的状态数为计算的时间复杂度$T_M(I)$，计算中所占用的带方格数为空间复杂度$S_M(I)$。

**<font color=yellow>定义：多项式时间可解的</font>**：存在一个解答$\pi$的 DTM 程序$M$，和多项式函数$P(n)$，使$T_M(n) \leq P(n)$，则称$M$是多项式时间程序。

如果问题$\pi$存在多项式时间的程序，则称问题$\pi$是多项式时间可计算的——**P 类问题**

<font color=yellow>在计算机上多项式时间算法，等价于 DTM 多项式时间程序</font>

### 非确定图灵机与 NP 类

非确定图灵机：NTM

NTM 工作分为：

1.  猜测阶段：猜测部件写在带上的一些符号
2.  验证阶段：执行

NTM 实际上是验证机器，由猜测部件去猜最好的符号串，然后状态控制器根据符号去执行最好的动作，从而求出最优解，根据猜测部件求出的解回答结果。

- 猜测部件猜测正确，则我们只需要编验证程序就行，如果猜错就无法保证最后回答
- 猜测部件应能保证能猜出来

**<font color=yellow>定义：非多项式时间可解的</font>**：存在解答$\pi$的一个验证程序$M$，和多项式函数$P(n)$，使$T_{NTM}(n) \leq P(n)$。如果验证时间是多项式的就是 NTM 多项式时间可解的——NP 类问题

**定理**：NP 类的问题，均可用 DTM 在$T(n)=O(2^{P(n)})$时间内求解。

### 多项式变换（归约）与 NPC 类

**<font color=yellow>多项式变换定义</font>**：希望将$\pi_1$变为$\pi_2$，若$\pi_2$多项式时间可解，则$\pi_1$也多项式时间可解。

$$
\pi_1=<\Sigma_1, L_1, \phi_1>; \pi_2=<\Sigma_2, L_2, \phi_2>,\\

f: \Sigma_1^* \to \Sigma_2^*, I \in L_1, f(I) \in L_2, \phi_1(I)=\phi_2(f(I))
$$

其中，$f$变换能够在$p(|I|=n)$时间内计算完成，**则$f$称为由$\pi_1$到$\pi_2$的多项式归约**

若$\pi_1$可以多项式归约到$\pi_2$，则：若$\pi_2$存在多项式算法，则$\pi_1$也有多项式算法：

$$
\pi_1=<\Sigma_1, L_1, \phi_1>; \pi_2=<\Sigma_2, L_2, \phi_2>,\\

f: \Sigma_1^* \to \Sigma_2^*, I \in L_1, f(I) \in L_2,\\
\phi_1(I)=1\longleftrightarrow\phi_2(f(I))=1
$$

若有一个特殊的 NP 问题$\pi$，任意一个 NP 问题均可多项式时间归约到该问题，则该问题是 NP-Complete(NPC)的。

若该 NPC 问题可以多项式时间解决，则其他所有 NP 问题都可以在多项式时间解决。

$\propto$ 是多项式变换符号，

**定义**：$\pi \in NP, \forall \pi_1 \in NP,\pi_1 \propto \pi$，则称$\pi$是 NPC 的

**定理**：若有$\pi \in NPC$，则（1）$P \neq NP$，（2）$\pi \notin P$，即$P \neq NP \longleftrightarrow \pi \notin P$

### 图灵归约与 NP-Hard

图灵归约用于证明一个问题是 NP-hard，从而说明某些搜索问题的计算复杂性。其定义基于神谕图灵机(Oracle Turing Machine, OTM)。

OTM 和 DTM 很相似，但比 DTM 多了一个神谕状态，和神谕纸带。

这多出来的神谕状态可以被看做是一个黑盒子函数，用于帮助我们求解某些难以求解的问题。

**比如，已知货郎判定问题是 NP-hard，那么货郎优化问题的难度应该如何表示？**

假设存在一个在多项式时间内解货郎优化问题的算法 A，随后用该算法求出最短路径 L，如果 L 大于判定问题，就输出 NO，否则输出 YES。通过这种方法，我们用货郎优化问题解决了货郎判定问题

在上面的例子中，算法 A 就是神谕，以假设货郎优化问题的算法为多项时间为基础，设计算法并证明货郎判定问题是多项式时间的过程，被称为图灵归约。上述的过程读作将货郎判定问题图灵归约到货郎优化问题。此时，根据图灵归约的定义，货郎判定问题是 NP-hard，因此货郎优化问题也是 NP-hard。

> 可以看出，如果货郎优化问题可以在多项式时间内解答，那么货郎判定问题一定可以在多项式时间内解答；但是如果货郎判定问题可以在多项式时间内解答，根据上述算法，货郎优化问题不一定可以在多项式时间内解答。（可以根据上述图灵归约认定货郎优化问题比货郎判定问题难）
> 不过实际上，也可以将货郎优化问题图灵归约到货郎判定问题。这种情况下就可以认为货郎优化问题是 NP 等价的。

NPH 问题不一定在多项式时间内被验证正确性，NPC 为 NPH 的子集，因此 NPC 问题也可以看作是 NPH

将问题 A 图灵归约到问题 B，分以下几步：

1.  假设存在一个复杂度为 $O(1)$ 的求解问题 B 的算法 $M$
2.  利用算法 $M$ 设计一个多项式时间算法解决问题 A。

其中，说明问题 B 是 NP 的步骤可以省略，因为 NP-hard 不要求问题是 NP 的。

NP-hard 问题由图灵归约得到，有三种途径：

1.  一个问题能由任意一个 NP 问题图灵归约到该问题，则该问题是 NP-Hard。
2.  一个问题能由某个 NPC 问题图灵归约到该问题，则该问题为 NP-hard。
3.  若 $\pi_{1}$ 是 NP-hard 问题， $\pi_{1}$ 可以图灵归约到 $\pi_{2}$（即 $\pi_{1}\propto_t \pi_{2}$）, 则 $\pi_{2}$ 也是 NP-hard 问题。

### 几个的关系

当$P \neq NP$， NP 问题和 NPH 问题交集为 NPC 问题；当$P=NP$时，则有$P = NP = NPC$

| 类型 | P 时间内可验证 | P 时间内可求解 |
| ---- | -------------- | -------------- |
| P    | Y              | Y              |
| NP   | Y              | Y or N \*      |
| NPC  | Y              | Unknown        |
| NPH  | Y or N \*\*    | Unknown        |

\* 一个 P 对应的 NP 问题，可以在多项式时间内解决($P \subseteq NP$)

\*\* 当一个 NPH 是 NPC 时，可以在多项式时间内解决($NPC \subseteq NPH$)

## 一般的问题

### 判定问题

如划分问题、团问题

### 搜索（优化）问题

如 TSP

## 图论/离散基础

### 平面图

如果能将图 $G$ 除顶点外的边不相交地画在平面上，则称 $G$ 是平面图。

这个画出的没有边相交的图称为 $G$ 的平面嵌入。没有，也就是不存在平面嵌入的图称作非平面图。

![1735698065080](https://github.com/lupnis/mes_blogs/blob/master/res/image/sdu_adalgo/1735698065080.png?raw=true)

- 图(e)为非平面图

### 哈密顿图和哈密顿回路问题

具有哈密顿回路的图称为哈密顿图，具有哈密顿通路但不具有哈密顿回路的图称为半哈密顿图。

这个问题和著名的七桥问题的不同之处在于，过桥只需要确定起点，而不用确定终点。哈密顿问题寻找一条从给定的起点到给定的终点沿途恰好经过所有其他城市一次的路径。

平凡图是哈密顿图。

寻找哈密顿路径是一个典型的NPC问题。后来人们也证明了，找一条哈密顿路的近似比为常数的近似算法也是NPC的。

$G=(V,E)$是一个图，若$G$中一条通路通过且仅通过每一个顶点一次，称这条通路为哈密尔顿通路。若$G$中一个圈通过且仅通过每一个顶点一次，称这个圈为哈密尔顿圈。若一个图存在哈密尔顿圈，就称为哈密尔顿图。

#### 哈密尔顿图的必要条件

若$G=(V,E)$是一个哈密尔顿图，则对于V的每一个非空子集$S$，均有$W(G－S) \leq |S|$。其中|S|是S中的顶点数，$W(G－S)$表示图G擦去属于S中的顶点后，剩下子图的连通分枝的个数。

#### 哈密尔顿图的充分条件
设$G=(V,E)$是一个无向简单图，$|V|=n, n \geq 3$。若对于任意的两个顶点$u, v \in V，d(u)+d(v) \geq n$，那么, $G$是哈密尔顿图。此条件由美国图论数学家奥勒在1960年给出。

### 独立集

一个独立集（也称为稳定集）是一个图中一些两两不相邻的顶点所形成的集合，如果两个点没有公共边，那么这两个点可以被放到一个独立集中。换句话说，独立集 $S$ 由图中若干顶点组成，且 $S$ 中任两个顶点之间没有边。等价地，图中的每条边至多有一个端点属于 $S$ 。一个独立集的基数是它包含顶点的数目。

如下图中，所有灰色的点可以构成一个独立集，因为他们互相之间没有任何公共边。

![1735698221786](https://github.com/lupnis/mes_blogs/blob/master/res/image/sdu_adalgo/1735698221786.png?raw=true)

> 对于三个点组成的完全图而言，每个点自身是一个独立集（且是最大独立集）；对四个点构成的四边形图而言，对角的两个点组成一个独立集（且是最大独立集）。

#### 最大独立集

如果往图 $G$ 的独立集 $S$ 中添加任一个顶点都会使独立性丧失（亦即造成某两点间有边），那么称 $S$ 是极大独立集。

如果 $S$ 是图中所有独立集之中基数最大的，那么称 $S$ 是最大独立集，且将该基数称为 $G$ 的独立数，记为 $α(G)$ 。一般来讲，图 G 中可能存在多个极大独立集和最大独立集。

给定一张图，寻找其中一个最大独立集的问题被称为最大独立集问题。**该问题已知是 NP 困难的最优化问题，且即便试图以常数倍近似也是 NP 困难的**。因此，计算机科学家普遍相信不存在解决该问题的高效算法，无论是精确求解还是以常数倍近似求解。

### 对集 (matching)

指无公共端点的边的集合，也即该集合是边集，且这些边的所有端点在这个边集中只出现过一次，没有重复。

在赋权图的已有点上，使得权重之和最小的对集，被称为最小对集。

### 补图

一个图的补图是指和原图具有一样的点的图，但原图中两点之间存在边时候，补图对应点之间没有边；原图不存在边时，补图有边。因此，原图和补图中的边的合集构成了一张完全图。

### 二分图

二分图又称作二部图，是图论中的一种特殊模型。 设 $G=(V,E)$ 是一个无向图，如果顶点 $V$ 可分割为两个互不相交的子集 $(A,B)$，并且图中的每条边 $(i,j)$ 所关联的两个顶点 $i$ 和 $j$ 分别属于这两个不同的顶点集 $(i \in A,j \in B)$，则称图 $G$ 为一个二分图。

如下图，是一个二分图，因为点可以被分成两个点集，且每个集合内的点之间互不相邻（互相之间没有边连接）

![图](https://i-blog.csdnimg.cn/blog_migrate/fda429e87f533fa6e6677b6f69ed7b8a.png)

二分图判断一般使用染色法，即从其中一个顶点开始，将跟它邻接的点染成与其不同的颜色，如果邻接的点有相同颜色的，则说明不是二分图。每次用bfs遍历染色即可。

# 布尔可满足性问题 (boolean SATisfiability problem, SAT)

## SAT 介绍

SAT 问题属于决定性问题，也是第一个被证明属于 NPC 的问题，1970 年 Cook 证明 SAT 问题是 NPC 问题。即 Cook 定理。Cook 说明若 SAT 多项式时间可解，则所有 NP 问题多项式时间可解。

Cook 定理证明 SAT 问题属于 NPC 问题的核心步骤：

1.  证明 SAT 问题属于 NP 问题，这明显成立（给定一个真值指派，按顺序求解即可）
2.  证明其他所有属于 NP 类的判定问题都可以通过某多项式变换变换为 SAT 问题

## SAT 问题定义

布尔变量集合$U=\left\{u_{1}, u_{2}, \cdots, u_{n}\right\}$，项集合$C=\left\{C_{1}, C_{2}, \cdots, C_{m}\right\}$，其中：

$$
C_{i}=\left\{u[i, 1], \cdots, u\left[i, k_{i}\right]\right\}
\subseteq U \cup \bar{U}, \quad \bar{U}=\left\{\bar{u}_{1}, \cdots, \bar{u}_{n}\right\}
$$

询问 是否存在 $U$ 的真值指派:$U \rightarrow\{\mathrm{F}, \mathrm{T}\}$，满足

$$
\bigwedge_{i=1}^{m}\left(\sum_{j=1}^{k_{i}} u[i, j]\right)=\mathrm{T}
$$

## SAT 问题证明

设布尔表达式可满足性问题为$SAT=\{x \in \{0,1\}*\}$

# 2SAT

# 3SAT

# TSP

# 背包

# 划分

# 独立集

# 独立任务排工

# 顶点覆盖

# 集合覆盖
